/*
 * Copyright (C) 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.copybara.util;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableMap;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.List;
import java.util.Map.Entry;
import java.util.Objects;

/**
 * SinglePatch represents the difference between what exists in the destination files and the output
 * of an import created by Copybara. This will only be different when using merge import mode,
 * because otherwise the destination files will be overwritten and there will be no difference.
 */
public class SinglePatch {

  private static final String header = ""
      + "# This file is generated by Copybara.\n"
      + "# Do not edit.\n";

  private static final String hashSectionDelimiterLine = "--hash-delimiter--";


  private final ImmutableMap<String, String> fileHashes;
  private final byte[] diffContent;

  public SinglePatch(ImmutableMap<String, String> fileHashes, byte[] diffContent) {
    this.fileHashes = fileHashes;
    this.diffContent = diffContent;
  }

  private static String mustReadLine(BufferedReader reader) throws IOException {
    String line = reader.readLine();
    if (line == null) {
      throw new IOException("failed to parse single patch file: unexpected end of file");
    }
    return line;
  }

  private static String mustReadUncommentedLine(BufferedReader reader) throws IOException {
    String line = mustReadLine(reader);
    while (line.startsWith("#")) {
      line = mustReadLine(reader);
    }
    return line;
  }

  public static SinglePatch fromBytes(byte[] bytes) throws IOException {
    try (
        ByteArrayInputStream in = new ByteArrayInputStream(bytes);
        BufferedReader br = new BufferedReader(new InputStreamReader(in))
    ) {
      ImmutableMap.Builder<String, String> fileHashesBuilder = new ImmutableMap.Builder<>();
      String line = mustReadUncommentedLine(br);

      while (!line.equals(hashSectionDelimiterLine)) {
        List<String> splits = Splitter.on(" ").limit(2).splitToList(line);
        if (splits.size() != 2) {
          throw new IOException(
              "failed to parse single patch hashes: unexpected number of elements");
        }
        fileHashesBuilder.put(splits.get(0), splits.get(1));

        line = mustReadUncommentedLine(br);
      }

      line = br.readLine();
      ByteArrayOutputStream diffContentOut = new ByteArrayOutputStream();
      try (OutputStreamWriter diffContentWriter = new OutputStreamWriter(diffContentOut)) {
        while (line != null) {
          diffContentWriter.write(line + "\n");
          line = br.readLine();
        }
      }

      return new SinglePatch(fileHashesBuilder.build(), diffContentOut.toByteArray());
    }

  }

  public ImmutableMap<String, String> getFileHashes() {
    return fileHashes;
  }

  public byte[] getDiffContent() {
    return Arrays.copyOf(diffContent, diffContent.length);
  }

  byte[] toBytes() throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    // OutputStreamWriter for this part for idiomatic string writing
    try (OutputStreamWriter outWriter = new OutputStreamWriter(out)) {
      outWriter.write(header);

      for (Entry<String, String> entry : fileHashes.entrySet()) {
        outWriter.write(String.format("%s %s\n",
            entry.getKey(),
            entry.getValue()));
      }
      outWriter.write(hashSectionDelimiterLine + "\n");
    }

    out.write(diffContent);

    return out.toByteArray();
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }

    if (!(obj instanceof SinglePatch)) {
      return false;
    }

    SinglePatch that = (SinglePatch) obj;
    if (!this.fileHashes.equals(that.fileHashes)) {
      return false;
    }

    return Arrays.equals(this.diffContent, that.diffContent);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fileHashes.hashCode(), Arrays.hashCode(this.diffContent));
  }

  @Override
  public String toString() {
    return String.format("%s\n%s\n", fileHashes, new String(diffContent, UTF_8));
  }

}
